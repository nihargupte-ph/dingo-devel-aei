import matplotlib.pyplot as plt
import os 
from abc import ABC
from functools import partial
import numpy as np
import pandas as pd

import bilby
import scipy
from matplotlib import colors
import scipy.stats
from chainconsumer import ChainConsumer

from dingo.gw.domains import build_domain, build_domain_from_model_metadata


def effective_spin(chi_1, chi_2, mass_ratio):
    a = chi_1 + mass_ratio * chi_2
    b = 1 + mass_ratio
    return a / b


def get_snr(domain, asd, strain_data, duration=8.0):
    """
    Given an injection generated by Injection.injection or Injection.random_injection
    will return snr of the injection in the two detectors

    Returns
    -------
    dict
        keys:
            detector: data (signal + noise) in each detector
    """
    snrs = {k: None for k in strain_data["waveform"].keys()}
    freq_snr_squared = {k: None for k in strain_data["waveform"].keys()}

    for ifo_name, ifo_signal in strain_data["waveform"].items():

        integrand = (np.conj(ifo_signal) * ifo_signal) / (
            (asd[ifo_name] ** 2) * domain.window_factor
        )
        freq_snr_squared[ifo_name] = (4 / duration) * integrand
        snrs[ifo_name] = ((4 / duration) * np.sum(integrand)) ** 0.5

    network_snr = np.sqrt(
        sum([snrs[ifo_name] ** 2 for ifo_name in strain_data["waveform"].keys()])
    )
    return snrs, freq_snr_squared, network_snr


class PosteriorList:
    def __init__(self):
        self.data_dict = {}

    def append_var(self, var):
        self.data_dict[var] = {"truth": None, "posteriors": None, "snr": None, "ess": None}

    def append_posterior(self, var, new_posterior):
        if self.data_dict[var]["posteriors"] == None:
            self.data_dict[var]["posteriors"] = {
                k: v.reshape(1, -1) for k, v in new_posterior.items()
            }
        else:
            for k in self.data_dict[var]["posteriors"].keys():
                posterior = np.concatenate(
                    [
                        self.data_dict[var]["posteriors"][k],
                        new_posterior[k].reshape(1, -1),
                    ],
                    axis=0,
                )
                self.data_dict[var]["posteriors"][k] = posterior

    def append_truth(self, var, truth):
        self.data_dict[var]["truth"] = truth

    def append_snr(self, var, snr):
        if self.data_dict[var]["snr"] == None:
            self.data_dict[var]["snr"] = [snr]
        else:
            self.data_dict[var]["snr"] = self.data_dict[var]["snr"] + [snr]
        
    def append_ess(self, var, ess, sample_efficiency):
        self.data_dict[var] = {
            "ess": ess,
            "sample_efficiency": sample_efficiency
        }

    def __getitem__(self, idx, conflation=False):
        return self.data_dict[list(self.data_dict.keys())[idx]]

    def get_mean(self, idx):
        posteriors = self.__getitem__(idx)["posteriors"]
        ret = {k: v.flatten().mean() for k, v in posteriors.items()}
        return ret

    def get_median(self, idx):
        posteriors = self.__getitem__(idx)["posteriors"]
        ret = {k: np.median(v.flatten()) for k, v in posteriors.items()}
        return ret


    def get_std(self, idx):
        posteriors = self.__getitem__(idx)["posteriors"]
        ret = {k: v.flatten().std() for k, v in posteriors.items()}
        return ret

    def __len__(self):
        return len(self.data_dict)

    @property
    def index_vars(self):
        return list(self.data_dict.keys())


class Bias(ABC):
    def __init__(self, sampler, injection_generator, _injection_parameters):
        self.sampler = sampler
        self.domain = build_domain_from_model_metadata(sampler.model.metadata)
        self.injection_generator = injection_generator
        self.injection_parameters = _injection_parameters

    @property
    def injection_parameters(self):
        # There are additional injection parameters which can be derived
        ret = self._injection_parameters
        # FIXME need to implement effective spin for precession
        if not "phi_jl" in list(self._injection_parameters.keys()):
            if "chi_eff" in list(self._injection_parameters.keys()):
                # Assuming only scheme right now is symmetric spin
                ret["chi_1"] = ret["chi_eff"]
                ret["chi_2"] = ret["chi_eff"]
            else:
                ret["chi_eff"] = effective_spin(
                    ret["chi_1"],
                    ret["chi_2"],
                    ret["mass_ratio"],
                )

        if "total_mass" in list(self._injection_parameters.keys()):
            (
                mass_1,
                mass_2,
            ) = bilby.gw.conversion.total_mass_and_mass_ratio_to_component_masses(
                self._injection_parameters["mass_ratio"],
                self._injection_parameters["total_mass"],
            )
            ret["mass_1"] = mass_1
            ret["mass_2"] = mass_2
        else:
            ret[
                "total_mass"
            ] = bilby.gw.conversion.chirp_mass_and_mass_ratio_to_total_mass(
                ret["chirp_mass"],
                ret["mass_ratio"],
            )

        (
            mass_1,
            mass_2,
        ) = bilby.gw.conversion.total_mass_and_mass_ratio_to_component_masses(
            ret["mass_ratio"], ret["total_mass"]
        )
        ret["mass_1"] = mass_1
        ret["mass_2"] = mass_2
        ret = pd.DataFrame(ret)
        return ret

    @injection_parameters.setter
    def injection_parameters(self, _injection_parameters):
        self._injection_parameters = _injection_parameters
        self._injection_parameters = {
            k: v * np.ones(self.length) for k, v in self._injection_parameters.items()
        }

    def check_prior(self, params):
        # NOTE NOTE NOTE this function is BROKEN RIGHT NOW NOT EVEN CHECKING PRIORS!
        tmp_result = self.sampler.to_result()
        prior = tmp_result.prior
        for param_name, sweep_array in params.items():
            if not param_name in list(prior.keys()):
                print(f"Parameter {param_name} not in prior")
            else:
                if sweep_array.min() < prior[param_name].minimum or sweep_array.max() > prior[param_name].maximum:
                    raise Exception(f"Parameter {param_name} not in prior range")

        return True

    def rescale_distance(self, target_snr):
        """
        Given a target network snr and parameters for a waveform, will rescale the luminosity distance, parameters["luminosity_distance"] such that now the network snr
        of the signal generated by parameters is the target_snr
        """

        def f(domain, parameters, injection_generator, target_snr, d_L):
            parameters["luminosity_distance"] = d_L
            _, _, network_snr = get_snr(
                domain, injection_generator.asd, injection_generator.signal(parameters)
            )
            opt = (target_snr - network_snr.real) ** 2
            return opt

        rescaled_injection_parameters = self.injection_parameters.copy()
        x0 = self.injection_parameters["luminosity_distance"][0]
        for idx, parameters in rescaled_injection_parameters.copy().iterrows():
            g = partial(
                f, self.domain, parameters, self.injection_generator, target_snr
            )
            res = scipy.optimize.minimize(g, x0=x0, tol=1e-2)
            x0 = res.x
            # param = {"luminosity_distance": np.array(res.x)}
            # self.check_prior(param)
            rescaled_injection_parameters["luminosity_distance"][idx] = res.x
        self._injection_parameters = rescaled_injection_parameters

    def recalculate_params(self):
        self.sampler.samples["mass_1"], self.sampler.samples["mass_2"] = bilby.gw.conversion.chirp_mass_and_mass_ratio_to_component_masses(
            self.sampler.samples["chirp_mass"], 
            self.sampler.samples["mass_ratio"]
        )
        self.sampler.samples["total_mass"] = self.sampler.samples["mass_1"] + self.sampler.samples["mass_2"]
        self.sampler.samples["chi_eff"] = effective_spin(self.sampler.samples["chi_1"], self.sampler.samples["chi_2"], self.sampler.samples["mass_ratio"])

class Bias1D(Bias):
    def __init__(self, sampler, injection_generator, params, injection_parameters):
        
        if len(np.unique([sa.shape for sa in params.values()])) == 1:
            self.length = list(params.values())[0].shape[0]
        else:
            raise Exception("Sweep arrays should all be the same shape")
        super().__init__(sampler, injection_generator, injection_parameters)
        self.param_names = list(params.keys())
        self.params = params
        self.check_prior(self.params)
        for param_name, sweep_array in self.params.items():
            self._injection_parameters[param_name] = sweep_array

    def sweep(
        self, num_samples=1_000, batch_size=1_000, num_avg_points=1, interest_params="*"
    ):
        if interest_params == "*":
            interest_params = [p for p in self.sampler.prior.keys()]
        self.interest_params = interest_params
        self.posterior_list = PosteriorList()
        # Iterate through the injection parameters and for each one generate a posterior
        for idx in self.injection_parameters.index:
            # Record the sweep array value for each posterior, this serves as a key
            var = tuple([self.injection_parameters[n][idx] for n in self.param_names])
            self.posterior_list.append_var(var)
            truth = {k:(self.injection_parameters.iloc[idx][k] if k in self.injection_parameters.columns else 0) for k in interest_params}
            self.posterior_list.append_truth(var, truth)

            for _ in range(num_avg_points):
                strain_data = self.injection_generator.injection(
                    self.injection_parameters.iloc[idx]
                )
                self.sampler.context = strain_data.copy()
                self.sampler.run_sampler(
                    num_samples=num_samples,
                    batch_size=batch_size,
                )
                result = self.sampler.to_result()
                # result.importance_sample()
                _, _, network_snr = get_snr(
                    self.domain, self.injection_generator.asd, strain_data
                )
                self.posterior_list.append_snr(var, network_snr.real)
                # self.posterior_list.append_ess(var, result.effective_sample_size, result.sample_efficiency)
                self.posterior_list.append_posterior(
                    var,
                    {k: self.sampler.samples[k].to_numpy() for k in interest_params},
                )

    def plot(self, ax, plot_param, plot_kwargs={"avg": {}, "std": {}, "truth": {}}, x_values=None):
        if plot_param not in self.interest_params:
            raise Exception(
                f"{plot_param} not in self.interest_params = {self.interest_params}"
            )
        
        # Adding a the sweep parameter on a line 
        if x_values is None:
            x_values = {
                "name": self.param_names[0],
                "array": [i[0] for i in self.posterior_list.data_dict.keys()]
            }
        ax.set_xlabel(x_values["name"])
        ax.set_ylabel(plot_param)
        avg = np.array(
            [
                self.posterior_list.get_mean(idx)[plot_param]
                for idx in range(len(self.posterior_list))
            ]
        )
        std = np.array(
            [
                self.posterior_list.get_std(idx)[plot_param]
                for idx in range(len(self.posterior_list))
            ]
        )
        truth = [self.posterior_list[i]["truth"][plot_param] for i in range(len(x_values["array"]))]
        ax.plot(x_values["array"], avg, label=r"SEOBNRv4HM_ROM $\pm 1 \sigma$", **plot_kwargs["avg"])
        ax.fill_between(x_values["array"], avg - std, avg + std, alpha=0.5, **plot_kwargs["std"])
        out = ax.plot(x_values["array"], truth, label="Truth", **plot_kwargs["truth"])
        return out

    def save_frame(self, idx, fpath, x_values=None, **kwargs):

        truth = self.posterior_list[idx]["truth"]
        c = ChainConsumer()
        c.add_chain(
            {
                k: self.posterior_list[idx]["posteriors"][k].flatten()
                for k in self.posterior_list[idx]["posteriors"].keys()
            },
            **kwargs,
        )
        c.configure(
            linestyles=["-"],
            linewidths=[1.5],
            sigmas=[np.sqrt(2) * scipy.special.erfinv(x) for x in [0.5, 0.9]],
            shade=[False],
            shade_alpha=0.3,
            bar_shade=False,
            label_font_size=10,
            tick_font_size=10,
            usetex=False,
            legend_kwargs={"fontsize": 30},
        )

        tmp_result = self.sampler.to_result()
        prior = tmp_result.prior
        extents = {k: (v.minimum, v.maximum) for k, v in prior.items()}
        # Custom extents for some parameters 
        if "domega220" in list(extents.keys()):
            extents["domega220"] = (-0.8, 2)
        if "dtau220" in list(extents.keys()):
            extents["dtau220"] = (-0.8, 2)
        if "chirp_mass" in list(extents.keys()):
            extents["chirp_mass"] = (20, 40)

        fig = c.plotter.plot(
            truth=truth,
            extents=extents
        )

        # Adding a the sweep parameter on a line 
        if x_values is None:
            x_values = {
                "name": self.param_names[0],
                "array": [i[0] for i in self.posterior_list.data_dict.keys()]
            }
        num_plots = str(int(len(fig.axes) ** 0.5))
        sweep_ax = fig.add_subplot(int(num_plots*3))
        # sweep_ax.set_facecolor('r')
        y = 0 
        xmin = x_values["array"].min()
        xmax = x_values["array"].max()
        height = 1
        sweep_ax.set_xlim(xmin, xmax)
        sweep_ax.set_ylim(0, 10)
        sweep_ax.axhline(y=5, linestyle='-')
        sweep_ax.get_yaxis().set_visible(False)
        sweep_ax.scatter(x_values["array"][idx], 5, c='b', zorder=5, marker='x')
        sweep_ax.set_xlabel(x_values["name"])


        fig.set_figwidth(10)
        fig.set_figheight(10)
        fig.savefig(fpath, dpi=300)
        plt.close()

    def save_frames_for_video(self, outdir, x_values=None, **kwargs):
        os.makedirs(outdir, exist_ok=True)
        for idx in range(len(self.posterior_list)):
            self.save_frame(idx, outdir + f"/{idx:03d}", x_values=x_values, **kwargs)

        ret = f""" rsync -rav nihargupte@saraswati:{outdir}/* . && ffmpeg -y -r 5 -i %03d.png -c:v libx264 -vf "format=yuv420p,fps=7" out.mp4 """
        return ret

class Bias2D(Bias):
    def __init__(
        self, sampler, injection_generator, param1, param2, injection_parameters
    ):
        self.length = (
            param1["sweep_array"].shape[0] * param2["sweep_array"].shape[0]
        )  # Technically this should be an abstract property but FIXME
        super().__init__(sampler, injection_generator, injection_parameters)
        self.param1 = param1
        self.param2 = param2
        check_params = {
            param1["name"]: param1["sweep_array"],
            param2["name"]: param2["sweep_array"]
        }
        self.check_prior(check_params)

        param1_arr, param2_arr = np.meshgrid(
            param1["sweep_array"], param2["sweep_array"]
        )
        param1_arr, param2_arr = param1_arr.flatten(), param2_arr.flatten()
        self._injection_parameters[param1["name"]] = param1_arr
        self._injection_parameters[param2["name"]] = param2_arr
        self.injection_parameters = self._injection_parameters

    def sweep(self, num_samples, batch_size, num_avg_points, interest_params):
        self.interest_params = interest_params
        self.posterior_list = PosteriorList()
        for idx in self.injection_parameters.index:
            var = (
                self.injection_parameters[self.param1["name"]][idx],
                self.injection_parameters[self.param2["name"]][idx],
            )
            self.posterior_list.append_var(var)
            truth = {k: self.injection_parameters.iloc[idx][k] for k in interest_params}
            self.posterior_list.append_truth(var, truth)

            for _ in range(num_avg_points):
                strain_data = self.injection_generator.injection(
                    self.injection_parameters.iloc[idx]
                )
                self.sampler.context = strain_data.copy()
                self.sampler.run_sampler(
                    num_samples=num_samples,
                    batch_size=batch_size,
                )
                _, _, network_snr = get_snr(
                    self.domain,
                    self.injection_generator.asd,
                    self.injection_generator.signal(
                        self.injection_parameters.iloc[idx]
                    ),
                )
                self.posterior_list.append_snr(var, network_snr)
                self.recalculate_params()
                self.posterior_list.append_posterior(
                    var,
                    {k: self.sampler.samples[k].to_numpy() for k in interest_params},
                )

    def plot(self, ax, plot_param, mode="average", plot_type="pcolormesh", **kwargs):
        if plot_param not in self.interest_params:
            raise Exception(
                f"{plot_param} not in self.interest_params = {self.interest_params}"
            )
        ax.set_xlabel(self.param1["name"])
        ax.set_ylabel(self.param2["name"])
        x = np.array(list(self.posterior_list.data_dict.keys()))
        if mode == "average":
            avg = np.array(
                [
                    self.posterior_list.get_mean(idx)[plot_param]
                    for idx in range(len(self.posterior_list))
                ]
            )
            truth = np.array(
                [self.posterior_list[i]["truth"][plot_param] for i in range(x.shape[0])]
            )
            Z = avg - truth

        elif mode == "median":
            avg = np.array(
                [
                    self.posterior_list.get_median(idx)[plot_param]
                    for idx in range(len(self.posterior_list))
                ]
            )
            truth = np.array(
                [self.posterior_list[i]["truth"][plot_param] for i in range(x.shape[0])]
            )
            Z = avg - truth

        elif mode == "variance":
            std = np.array(
                [
                    self.posterior_list.get_std(idx)[plot_param]
                    for idx in range(len(self.posterior_list))
                ]
            )
            Z = std

        elif mode == "mode":
            mode = np.array(
                [
                    scipy.stats.mode(self.posterior_list[idx]["posteriors"][plot_param])
                    for idx in range(len(self.posterior_list))
                ]
            )
            truth = np.array(
                [self.posterior_list[i]["truth"][plot_param] for i in range(x.shape[0])]
            )
            Z = mode - truth

        else:
            raise Exception("Allowed modes are 'average', 'median', 'mode' and 'variance'")

        X, Y = x[:, 0], x[:, 1]
        if plot_type == "pcolormesh":
            xl = int(X.shape[0] / self.param1["sweep_array"].shape[0])
            yl = int(Y.shape[0] / self.param2["sweep_array"].shape[0])
            XX = np.reshape(X, (xl, xl))
            YY = np.reshape(Y, (yl, yl))
            ZZ = np.reshape(Z, (xl, yl))     
            divnorm = colors.TwoSlopeNorm(vmin=ZZ.min(), vcenter=0, vmax=ZZ.max())
            out = ax.pcolormesh(XX, YY, ZZ, norm=divnorm, **kwargs)
        elif plot_type == "tricontourf":
            out = ax.tricontourf(X, Y, Z, **kwargs)
        else:
            raise Exception(f"Plot type {plot_type} not supported")
        return out, ax
