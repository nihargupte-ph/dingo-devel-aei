import matplotlib.pyplot as plt
from abc import ABC
from functools import partial
import numpy as np
import pandas as pd

import bilby
import scipy
import scipy.stats
from chainconsumer import ChainConsumer

from dingo.gw.domains import build_domain, build_domain_from_model_metadata


def effective_spin(chi_1, chi_2, mass_ratio):
    a = chi_1 + mass_ratio * chi_2
    b = 1 + mass_ratio
    return a / b


def get_snr(domain, asd, strain_data, duration=8.0):
    """
    Given an injection generated by Injection.injection or Injection.random_injection
    will return snr of the injection in the two detectors

    Returns
    -------
    dict
        keys:
            detector: data (signal + noise) in each detector
    """
    snrs = {k: None for k in strain_data["waveform"].keys()}
    freq_snr_squared = {k: None for k in strain_data["waveform"].keys()}

    for ifo_name, ifo_signal in strain_data["waveform"].items():

        integrand = (np.conj(ifo_signal) * ifo_signal) / (
            (asd[ifo_name] ** 2) * domain.window_factor
        )
        freq_snr_squared[ifo_name] = (4 / duration) * integrand
        snrs[ifo_name] = ((4 / duration) * np.sum(integrand)) ** 0.5

    network_snr = np.sqrt(
        sum([snrs[ifo_name] ** 2 for ifo_name in strain_data["waveform"].keys()])
    )
    return snrs, freq_snr_squared, network_snr


class PosteriorList:
    def __init__(self):
        self.data_dict = {}

    def append_var(self, var):
        self.data_dict[var] = {"truth": None, "posteriors": None, "snr": None}

    def append_posterior(self, var, new_posterior):
        if self.data_dict[var]["posteriors"] == None:
            self.data_dict[var]["posteriors"] = {
                k: v.reshape(1, -1) for k, v in new_posterior.items()
            }
        else:
            for k in self.data_dict[var]["posteriors"].keys():
                posterior = np.concatenate(
                    [
                        self.data_dict[var]["posteriors"][k],
                        new_posterior[k].reshape(1, -1),
                    ],
                    axis=0,
                )
                self.data_dict[var]["posteriors"][k] = posterior

    def append_truth(self, var, truth):
        self.data_dict[var]["truth"] = truth

    def append_snr(self, var, snr):
        if self.data_dict[var]["snr"] == None:
            self.data_dict[var]["snr"] = [snr]
        else:
            self.data_dict[var]["snr"] = self.data_dict[var]["snr"] + [snr]

    def __getitem__(self, idx, conflation=False):
        return self.data_dict[list(self.data_dict.keys())[idx]]

    def get_mean(self, idx):
        posteriors = self.__getitem__(idx)["posteriors"]
        ret = {k: v.flatten().mean() for k, v in posteriors.items()}
        return ret

    def get_std(self, idx):
        posteriors = self.__getitem__(idx)["posteriors"]
        ret = {k: v.flatten().std() for k, v in posteriors.items()}
        return ret

    def __len__(self):
        return len(self.data_dict)

    @property
    def index_vars(self):
        return list(self.data_dict.keys())


class Bias(ABC):
    def __init__(self, sampler, injection_generator, _injection_parameters):
        self.sampler = sampler
        self.domain = build_domain_from_model_metadata(sampler.model.metadata)
        self.injection_generator = injection_generator
        self.injection_parameters = _injection_parameters
        pass

    @property
    def injection_parameters(self):
        # There are additional injection parameters which can be derived
        ret = self._injection_parameters
        if "effective_spin" in list(self._injection_parameters.keys()):
            # Assuming only scheme right now is symmetric spin
            ret["chi_1"] = ret["effective_spin"]
            ret["chi_2"] = ret["effective_spin"]
        else:
            ret["effective_spin"] = effective_spin(
                ret["chi_1"],
                ret["chi_2"],
                ret["mass_ratio"],
            )

        if "total_mass" in list(self._injection_parameters.keys()):
            (
                mass_1,
                mass_2,
            ) = bilby.gw.conversion.total_mass_and_mass_ratio_to_component_masses(
                self._injection_parameters["mass_ratio"],
                self._injection_parameters["total_mass"],
            )
            ret["mass_1"] = mass_1
            ret["mass_2"] = mass_2
        else:
            ret[
                "total_mass"
            ] = bilby.gw.conversion.chirp_mass_and_mass_ratio_to_total_mass(
                ret["chirp_mass"],
                ret["mass_ratio"],
            )

        (
            mass_1,
            mass_2,
        ) = bilby.gw.conversion.total_mass_and_mass_ratio_to_component_masses(
            ret["mass_ratio"], ret["total_mass"]
        )
        ret["mass_1"] = mass_1
        ret["mass_2"] = mass_2
        ret = pd.DataFrame(ret)
        return ret

    @injection_parameters.setter
    def injection_parameters(self, _injection_parameters):
        self._injection_parameters = _injection_parameters
        self._injection_parameters = {
            k: v * np.ones(self.length) for k, v in self._injection_parameters.items()
        }

    def check_prior(self, param):
        prior = self.sampler.prior
        if not param["name"] in list(prior.keys()):
            # If the user specifies effective spin
            if param["name"] == "effective_spin":
                max_effective_spin = effective_spin(
                    prior["chi_1"].maximum,
                    prior["chi_2"].maximum,
                    prior["mass_ratio"].maximum,
                )
                min_effective_spin = effective_spin(
                    prior["chi_1"].minimum,
                    prior["chi_2"].minimum,
                    prior["mass_ratio"].minimum,
                )
                if (
                    param["sweep_array"].min() < min_effective_spin
                    or param["sweep_array"].max() > max_effective_spin
                ):
                    raise Exception(f"Parameter {param['name']} not in prior range")
                return True
            else:
                raise Exception(f"Parameter {param['name']} not in prior")

        if (
            param["sweep_array"].min() < prior[param["name"]].minimum
            or param["sweep_array"].max() > prior[param["name"]].maximum
        ):
            raise Exception(f"Parameter {param['name']} not in prior range")

        return True

    def rescale_distance(self, target_snr):
        """
        Given a target network snr and parameters for a waveform, will rescale the luminosity distance, parameters["luminosity_distance"] such that now the network snr
        of the signal generated by parameters is the target_snr
        """

        def f(domain, parameters, injection_generator, target_snr, d_L):
            parameters["luminosity_distance"] = d_L
            _, _, network_snr = get_snr(
                domain, injection_generator.asd, injection_generator.signal(parameters)
            )
            return (target_snr - network_snr.real) ** 2

        rescaled_injection_parameters = self.injection_parameters.copy()
        for idx, parameters in rescaled_injection_parameters.copy().iterrows():
            g = partial(
                f, self.domain, parameters, self.injection_generator, target_snr
            )
            res = scipy.optimize.minimize_scalar(g)
            param = {"name": "luminosity_distance", "sweep_array": np.array(res.x)}
            self.check_prior(param)
            rescaled_injection_parameters["luminosity_distance"][idx] = res.x
        self._injection_parameters = rescaled_injection_parameters


class Bias1D(Bias):
    def __init__(self, sampler, injection_generator, param, injection_parameters):
        self.length = param[
            "sweep_array"
        ].shape  # Technically this should be an abstract property but FIXME
        super().__init__(sampler, injection_generator, injection_parameters)
        self.param = param
        self.check_prior(self.param)
        self._injection_parameters[self.param["name"]] = self.param["sweep_array"]

    def sweep(
        self, num_samples=1_000, batch_size=1_000, num_avg_points=1, interest_params="*"
    ):
        if interest_params == "*":
            interest_params = [p for p in self.sampler.prior.keys()]
        self.interest_params = interest_params
        self.posterior_list = PosteriorList()
        for idx in self.injection_parameters.index:
            var = self.injection_parameters[self.param["name"]][idx]
            self.posterior_list.append_var(var)
            truth = {k: self.injection_parameters.iloc[idx][k] for k in interest_params}
            self.posterior_list.append_truth(var, truth)

            for _ in range(num_avg_points):
                strain_data = self.injection_generator.injection(
                    self.injection_parameters.iloc[idx]
                )
                self.sampler.context = strain_data.copy()
                self.sampler.run_sampler(
                    num_samples=num_samples,
                    batch_size=batch_size,
                )
                _, _, network_snr = get_snr(
                    self.domain, self.injection_generator.asd, strain_data
                )
                self.posterior_list.append_snr(var, network_snr.real)
                self.posterior_list.append_posterior(
                    var,
                    {k: self.sampler.samples[k].to_numpy() for k in interest_params},
                )

    def plot(self, ax, plot_param, plot_kwargs={"avg": {}, "std": {}, "truth": {}}):
        if plot_param not in self.interest_params:
            raise Exception(
                f"{plot_param} not in self.interest_params = {self.interest_params}"
            )
        ax.set_xlabel(self.param["name"])
        ax.set_ylabel(plot_param)
        avg = np.array(
            [
                self.posterior_list.get_mean(idx)[plot_param]
                for idx in range(len(self.posterior_list))
            ]
        )
        std = np.array(
            [
                self.posterior_list.get_std(idx)[plot_param]
                for idx in range(len(self.posterior_list))
            ]
        )
        x = list(self.posterior_list.data_dict.keys())
        truth = [self.posterior_list[i]["truth"][plot_param] for i in range(len(x))]
        ax.plot(x, avg, label=r"SEOBNRv4HM_ROM $\pm 1 \sigma$", **plot_kwargs["avg"])
        ax.fill_between(x, avg - std, avg + std, alpha=0.5, **plot_kwargs["std"])
        out = ax.plot(x, truth, label="Truth", **plot_kwargs["truth"])
        return out

    def save_frame(self, idx, fpath, **kwargs):

        truth = self.posterior_list[idx]["truth"]
        c = ChainConsumer()
        c.add_chain(
            {
                k: self.posterior_list[idx]["posteriors"][k].flatten()
                for k in self.posterior_list[idx]["posteriors"].keys()
            },
            **kwargs,
        )
        c.configure(
            linestyles=["-"],
            linewidths=[1.5],
            sigmas=[np.sqrt(2) * scipy.special.erfinv(x) for x in [0.5, 0.9]],
            shade=[False],
            shade_alpha=0.3,
            bar_shade=False,
            label_font_size=10,
            tick_font_size=10,
            usetex=False,
            legend_kwargs={"fontsize": 30},
            kde=0.7,
        )

        fig = c.plotter.plot(
            truth=truth,
            extents={k: (v.minimum, v.maximum) for k, v in self.sampler.prior.items()},
        )
        fig.set_figwidth(10)
        fig.set_figheight(10)
        fig.savefig(fpath, dpi=300)
        return fig

    def save_frames_for_video(self, outdir, **kwargs):
        for idx in range(len(self.posterior_list)):
            self.save_frame(idx, outdir + f"/{idx:03d}", **kwargs)

        ret = """ rsync -rav nihargupte@saraswati:/home/local/nihargupte/dingo-devel/tutorials/05_data_vis/dumps/mass_ratio_bias .
        ffmpeg -y -r 5 -i mass_ratio_bias/%03d.png -c:v libx264 -vf "format=yuv420p,fps=30" out.mp4 """
        return ret


class Bias2D(Bias):
    def __init__(
        self, sampler, injection_generator, param1, param2, injection_parameters
    ):
        self.length = (
            param1["sweep_array"].shape[0] * param2["sweep_array"].shape[0]
        )  # Technically this should be an abstract property but FIXME
        super().__init__(sampler, injection_generator, injection_parameters)
        self.param1 = param1
        self.param2 = param2
        self.check_prior(self.param1)
        self.check_prior(self.param2)

        param1_arr, param2_arr = np.meshgrid(
            param1["sweep_array"], param2["sweep_array"]
        )
        param1_arr, param2_arr = param1_arr.flatten(), param2_arr.flatten()
        self._injection_parameters[param1["name"]] = param1_arr
        self._injection_parameters[param2["name"]] = param2_arr
        self.injection_parameters = self._injection_parameters

    def sweep(self, num_samples, batch_size, num_avg_points, interest_params):
        self.interest_params = interest_params
        self.posterior_list = PosteriorList()
        for idx in self.injection_parameters.index:
            var = (
                self.injection_parameters[self.param1["name"]][idx],
                self.injection_parameters[self.param2["name"]][idx],
            )
            self.posterior_list.append_var(var)
            truth = {k: self.injection_parameters.iloc[idx][k] for k in interest_params}
            self.posterior_list.append_truth(var, truth)

            for _ in range(num_avg_points):
                strain_data = self.injection_generator.injection(
                    self.injection_parameters.iloc[idx]
                )
                self.sampler.context = strain_data.copy()
                self.sampler.run_sampler(
                    num_samples=num_samples,
                    batch_size=batch_size,
                )
                _, _, network_snr = get_snr(
                    self.domain,
                    self.injection_generator.asd,
                    self.injection_generator.signal(
                        self.injection_parameters.iloc[idx]
                    ),
                )
                self.posterior_list.append_snr(var, network_snr)
                # NOTE ADD TOTAL MASS AND OTHER PARAMETERS OPTIONS HERE
                self.posterior_list.append_posterior(
                    var,
                    {k: self.sampler.samples[k].to_numpy() for k in interest_params},
                )

    def plot(self, ax, plot_param, mode="average", **kwargs):
        if plot_param not in self.interest_params:
            raise Exception(
                f"{plot_param} not in self.interest_params = {self.interest_params}"
            )
        ax.set_xlabel(self.param1["name"])
        ax.set_ylabel(self.param2["name"])
        x = np.array(list(self.posterior_list.data_dict.keys()))
        if mode == "average":
            avg = np.array(
                [
                    self.posterior_list.get_mean(idx)[plot_param]
                    for idx in range(len(self.posterior_list))
                ]
            )
            truth = np.array(
                [self.posterior_list[i]["truth"][plot_param] for i in range(x.shape[0])]
            )
            Z = avg - truth

        elif mode == "variance":
            std = np.array(
                [
                    self.posterior_list.get_std(idx)[plot_param]
                    for idx in range(len(self.posterior_list))
                ]
            )
            Z = std

        elif mode == "mode":
            mode = np.array(
                [
                    scipy.stats.mode(self.posterior_list[idx]["posteriors"][plot_param])
                    for idx in range(len(self.posterior_list))
                ]
            )
            truth = np.array(
                [self.posterior_list[i]["truth"][plot_param] for i in range(x.shape[0])]
            )
            Z = mode - truth

        else:
            raise Exception("Allowed modes are 'average', 'mode' and 'variance'")

        X, Y = x[:, 0], x[:, 1]
        out = ax.tricontourf(X, Y, Z, **kwargs)
        return out
